{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Network echos","text":"<p>A complex adaptive systems framework for modeling information diffusion, polarization, and echo chamber formation. Generate complex networks and simulate self-organization and emergent collective behavior driven by coupled interaction and reinforcement dynamics.</p>"},{"location":"#built-with","title":"Built with","text":""},{"location":"api-reference/core/","title":"netechos.core","text":"<p>Core functionality for the network echos model.</p>"},{"location":"api-reference/core/#src.netechos.core.NetworkModel","title":"<code>NetworkModel(number_of_nodes, interaction_type, alpha=1, beta=0.001)</code>","text":"<p>Object containing network model parameters and methods.</p> <p>Parameters:</p> Name Type Description Default <code>number_of_nodes</code> <code>int</code> <p>Number of nodes to add to the network model.</p> required <code>interaction_type</code> <code>Literal['symmetric', 'asymmetric']</code> <p>Type of interaction between nodes. If \"symmetric\" interactions will be reciprocated. If \"asymmetric\", interactions may be one-directional.</p> required <code>alpha</code> <code>float</code> <p>Exponent of the adjacency matrix during attitude reinforcement.</p> <code>1</code> <code>beta</code> <code>float</code> <p>Factor governing the rate of attitude change. Smaller values slow attitude change.</p> <code>0.001</code> <p>Returns:</p> Name Type Description <code>self</code> <code>Self @ NetworkModel</code> <p>An instance of the NetworkModel object.</p> Source code in <code>src/netechos/core.py</code> <pre><code>def __init__(\n    self: Self,\n    number_of_nodes: int,\n    interaction_type: Literal[\"symmetric\", \"asymmetric\"],\n    alpha: float = 1,\n    beta: float = 1e-3,\n) -&gt; Self:\n    \"\"\"Object storing network model data and methods.\n\n    Parameters\n    ----------\n    number_of_nodes : int\n        Number of nodes to add to the network model.\n    interaction_type : Literal[\"symmetric\", \"asymmetric\"]\n        Type of interaction between nodes. If \"symmetric\"\n        interactions will be reciprocated. If \"asymmetric\",\n        interactions may be one-directional.\n    alpha : float\n        Exponent of the adjacency matrix during attitude\n        reinforcement.\n    beta : float\n        Factor governing the rate of attitude change. Smaller\n        values slow attitude change.\n\n    Returns\n    -------\n    self : Self@NetworkModel\n        An instance of the NetworkModel object.\n\n    \"\"\"\n    allowed_types = [\"symmetric\", \"asymmetric\"]\n    if interaction_type not in allowed_types:\n        msg = f\"interaction_type must be one of: {allowed_types}.\"\n        raise ValueError(msg)\n    if number_of_nodes &lt; 1:\n        msg = \"number_of_nodes must be greater than one.\"\n        raise ValueError(msg)\n    self.number_of_nodes = number_of_nodes\n    self.interaction_type = interaction_type\n    self.adjacency_exponent = alpha\n    self.attitude_change_speed = beta\n</code></pre>"},{"location":"api-reference/core/#src.netechos.core.NetworkModel.compute_attitude_difference_matrix","title":"<code>compute_attitude_difference_matrix()</code>","text":"<p>Construct matrix of differences between node attitudes.</p> Source code in <code>src/netechos/core.py</code> <pre><code>def compute_attitude_difference_matrix(self: Self) -&gt; Self:\n    \"\"\"Construct matrix of differences between node attitudes.\"\"\"\n    self.attitude_diffs = np.subtract(\n        self.attitudes,\n        self.attitudes.transpose(),\n    )\n    return self\n</code></pre>"},{"location":"api-reference/core/#src.netechos.core.NetworkModel.create_network","title":"<code>create_network(network_type, p=0.1, k=2, m=1.0)</code>","text":"<p>Create initial social network.</p> <p>Parameters:</p> Name Type Description Default <code>network_type</code> <code>Literal['complete', 'erdos_renyi', 'watts_strogatz', 'newman_watts_strogatz', 'barabasi_albert']</code> <p>Type of network to create.</p> required <code>p</code> <code>float</code> <p>Required if network_type is one of 'erdos_renyi', 'watts_strogatz', 'newman_watts_strogatz'. Probability for edge creation.</p> <code>0.1</code> <code>k</code> <code>int</code> <p>Required if network_type is one of 'watts_strogatz', 'newman_watts_strogatz'. Each node is joined with its <code>k</code> nearest neighbors in a ring topology.</p> <code>2</code> <code>m</code> <code>float</code> <p>Required if network_type is 'barabasi_albert'. Number of edges to attach from a new node to existing nodes.</p> <code>1.0</code> <p>Returns:</p> Name Type Description <code>self</code> <code>Self @ NetworkModel</code> <p>An instance of the NetworkModel object.</p> Source code in <code>src/netechos/core.py</code> <pre><code>def create_network(\n    self: Self,\n    network_type: Literal[\n        \"complete\",\n        \"erdos_renyi\",\n        \"watts_strogatz\",\n        \"newman_watts_strogatz\",\n        \"barabasi_albert\",\n    ],\n    p: float = 0.1,\n    k: int = 2,\n    m: float = 1.0,\n) -&gt; Self:\n    \"\"\"Create initial social network.\n\n    Parameters\n    ----------\n    network_type: Literal[\"complete\", \"erdos_renyi\", \"watts_strogatz\", \"newman_watts_strogatz\", \"barabasi_albert\"]\n        Type of network to create.\n    p : float, optional, default: 0.1\n        Required if network_type is one of 'erdos_renyi',\n        'watts_strogatz', 'newman_watts_strogatz'. Probability for\n        edge creation.\n    k : int, optional, default: 2\n        Required if network_type is one of 'watts_strogatz',\n        'newman_watts_strogatz'. Each node is joined with its `k`\n        nearest neighbors in a ring topology.\n    m : float, optional, default: 1.0\n        Required if network_type is 'barabasi_albert'. Number\n        of edges to attach from a new node to existing nodes.\n\n    Returns\n    -------\n    self : Self@NetworkModel\n        An instance of the NetworkModel object.\n\n    \"\"\"  # noqa: E501\n    if network_type == \"complete\":\n        g_initial = nx.complete_graph(n=self.number_of_nodes)\n    if network_type == \"erdos_renyi\":\n        g_initial = nx.erdos_renyi_graph(n=self.number_of_nodes, p=p)\n        self.p_edge = p\n    if network_type == \"watts_strogatz\":\n        g_initial = nx.watts_strogatz_graph(\n            n=self.number_of_nodes,\n            k=k,\n            p=p,\n        )\n        self.k_neighbors = k\n        self.p_edge = p\n    if network_type == \"newman_watts_strogatz\":\n        g_initial = nx.newman_watts_strogatz_graph(\n            n=self.number_of_nodes,\n            k=k,\n            p=p,\n        )\n        self.k_neighbors = k\n        self.p_edge = p\n    if network_type == \"barabasi_albert\":\n        g_initial = nx.barabasi_albert_graph(n=self.number_of_nodes, m=m)\n        self.m_new_node_edges = m\n    self.social_network = g_initial\n    self.network_type = network_type\n    return self\n</code></pre>"},{"location":"api-reference/core/#src.netechos.core.NetworkModel.initialize_attitude_tracker","title":"<code>initialize_attitude_tracker()</code>","text":"<p>Initialize attitude tracking table.</p> Source code in <code>src/netechos/core.py</code> <pre><code>def initialize_attitude_tracker(self: Self) -&gt; Self:\n    \"\"\"Initialize attitude tracking table.\"\"\"\n    self.attitude_tracker = pl.DataFrame(\n        schema={\"time\": int, \"node\": int, \"attitude\": float},\n    )\n    return self\n</code></pre>"},{"location":"api-reference/core/#src.netechos.core.NetworkModel.initialize_attitudes","title":"<code>initialize_attitudes(distribution='vonmises', a=0.0, b=5)</code>","text":"<p>Set initial node attitudes.</p> <p>Parameters:</p> Name Type Description Default <code>distribution</code> <code>Literal['normal', 'uniform', 'laplace', 'vonmises']</code> <p>Type of probability distribution to sample attitudes from.</p> <code>'vonmises'</code> <code>a</code> <code>float</code> <p>First parameter for <code>distribution</code>. If <code>distribution</code> is 'normal' or 'laplace' this is the <code>loc</code> parameter. If <code>distribution</code> is 'uniform', this is the lower bound. If <code>distribution</code> is 'vonmises' this is the <code>mu</code> parameter.</p> <code>0.0</code> <code>b</code> <code>float</code> <p>Second parameter for <code>distribution</code>. If <code>distribution</code> is 'normal' or 'laplace' this is the <code>scale</code> parameter. If <code>distribution</code> is 'uniform', this is the upper bound. If <code>distribution</code> is 'vonmises' this is the <code>kappa</code> parameter.</p> <code>5</code> <p>Returns:</p> Name Type Description <code>self</code> <code>Self @ NetworkModel</code> <p>An instance of the NetworkModel object.</p> Source code in <code>src/netechos/core.py</code> <pre><code>def initialize_attitudes(\n    self: Self,\n    distribution: Literal[\n        \"normal\",\n        \"uniform\",\n        \"laplace\",\n        \"vonmises\",\n    ] = \"vonmises\",\n    a: float = 0.0,\n    b: float = 5,\n) -&gt; Self:\n    \"\"\"Set initial node attitudes.\n\n    Parameters\n    ----------\n    distribution : Literal['normal', 'uniform', 'laplace', 'vonmises'], default: 'vonmises'\n        Type of probability distribution to sample attitudes from.\n    a : float, default: 0.0\n        First parameter for `distribution`. If `distribution` is\n        'normal' or 'laplace' this is the `loc` parameter. If\n        `distribution` is 'uniform', this is the lower bound. If\n        `distribution` is 'vonmises' this is the `mu` parameter.\n    b : float, default: 5\n        Second parameter for `distribution`. If `distribution` is\n        'normal' or 'laplace' this is the `scale` parameter. If\n        `distribution` is 'uniform', this is the upper bound. If\n        `distribution` is 'vonmises' this is the `kappa` parameter.\n\n    Returns\n    -------\n    self : Self@NetworkModel\n        An instance of the NetworkModel object.\n\n    \"\"\"  # noqa: E501\n    rng = np.random.default_rng()\n    if distribution == \"normal\":\n        attitudes = rng.normal(\n            loc=a,\n            scale=b,\n            size=(1, self.number_of_nodes),\n        )\n        self.attitude_distribution_loc = a\n        self.attitude_distribution_scale = b\n    if distribution == \"laplace\":\n        attitudes = rng.laplace(\n            loc=a,\n            scale=b,\n            size=(1, self.number_of_nodes),\n        )\n        self.attitude_distribution_loc = a\n        self.attitude_distribution_scale = b\n    if distribution == \"vonmises\":\n        attitudes = rng.vonmises(\n            mu=a,\n            kappa=b,\n            size=(1, self.number_of_nodes),\n        )\n        self.attitude_distribution_mu = a\n        self.attitude_distribution_kappa = b\n    if distribution == \"uniform\":\n        attitudes = rng.uniform(\n            low=a,\n            high=b,\n            size=(1, self.number_of_nodes),\n        )\n        self.attitude_distribution_low = a\n        self.attitude_distribution_high = b\n    attitudes = np.clip(attitudes, a_min=-np.pi / 2, a_max=np.pi / 2)\n    self.attitudes = attitudes\n    self.attitude_distribution = distribution\n    return self\n</code></pre>"},{"location":"api-reference/core/#src.netechos.core.NetworkModel.initialize_connections","title":"<code>initialize_connections(neighbor_weight=1.0, non_neighbor_weight=0.0)</code>","text":"<p>Set initial network edge weights.</p> <p>Parameters:</p> Name Type Description Default <code>neighbor_weight</code> <code>float</code> <p>The weight to assign to edges between nodes which have an existing edge in the intial network.</p> <code>1.0</code> <code>non_neighbor_weight</code> <code>float</code> <p>The weight to assign to edges between nodes which don't have an existing edge in the intial network. If non-zero the network will technically become a complete network.</p> <code>0.0</code> <p>Returns:</p> Name Type Description <code>self</code> <code>Self @ NetworkModel</code> <p>An instance of the NetworkModel object.</p> Source code in <code>src/netechos/core.py</code> <pre><code>def initialize_connections(\n    self: Self,\n    neighbor_weight: float = 1.0,\n    non_neighbor_weight: float = 0.0,\n) -&gt; Self:\n    \"\"\"Set initial network edge weights.\n\n    Parameters\n    ----------\n    neighbor_weight : float\n        The weight to assign to edges between nodes which have an\n        existing edge in the intial network.\n    non_neighbor_weight : float\n        The weight to assign to edges between nodes which don't\n        have an existing edge in the intial network. If non-zero\n        the network will technically become a complete network.\n\n    Returns\n    -------\n    self : Self@NetworkModel\n        An instance of the NetworkModel object.\n\n    \"\"\"\n    adjacency_mat = nx.to_numpy_array(self.social_network)\n    adjacency_mat = neighbor_weight * adjacency_mat\n    adjacency_mat[adjacency_mat == 0] = non_neighbor_weight\n    self.connections = adjacency_mat\n    self.neighbor_weight = neighbor_weight\n    self.non_neighbor_weight = non_neighbor_weight\n    return self\n</code></pre>"},{"location":"api-reference/core/#src.netechos.core.NetworkModel.initialize_summary_table","title":"<code>initialize_summary_table()</code>","text":"<p>Initialize summary table.</p> Source code in <code>src/netechos/core.py</code> <pre><code>def initialize_summary_table(self: Self) -&gt; Self:\n    \"\"\"Initialize summary table.\"\"\"\n    self.summary_table = pl.DataFrame(\n        schema={\n            \"time\": int,\n            \"attitude_mean\": float,\n            \"attitude_sd\": float,\n            \"connection_mean\": float,\n            \"connection_sd\": float,\n        },\n    )\n    return self\n</code></pre>"},{"location":"api-reference/core/#src.netechos.core.NetworkModel.make_asymmetric_interactions","title":"<code>make_asymmetric_interactions()</code>","text":"<p>Construct a random asymmetric adjacency matrix.</p> Source code in <code>src/netechos/core.py</code> <pre><code>def make_asymmetric_interactions(self: Self) -&gt; Self:\n    \"\"\"Construct a random asymmetric adjacency matrix.\"\"\"\n    rng = np.random.default_rng()\n    rand_mat = rng.random(size=(self.number_of_nodes, self.number_of_nodes))\n    interactions = np.where(rand_mat &lt;= self.connections, 1, 0)\n    self.interactions = interactions\n    return self\n</code></pre>"},{"location":"api-reference/core/#src.netechos.core.NetworkModel.make_interactions","title":"<code>make_interactions()</code>","text":"<p>Construct interaction matrix.</p> Source code in <code>src/netechos/core.py</code> <pre><code>def make_interactions(self: Self) -&gt; Self:\n    \"\"\"Construct interaction matrix.\"\"\"\n    if self.interaction_type == \"symmetric\":\n        self.make_symmetric_interactions()\n    elif self.interaction_type == \"asymmetric\":\n        self.make_asymmetric_interactions()\n    else:\n        msg = f\"\"\"self.interaction_type must be one of [\"symmetric\",\n        \"asymmetric\"], got: {self.interaction_type}\"\"\"\n        raise ValueError(msg)\n    return self\n</code></pre>"},{"location":"api-reference/core/#src.netechos.core.NetworkModel.make_symmetric_interactions","title":"<code>make_symmetric_interactions()</code>","text":"<p>Construct a random symmetric adjacency matrix.</p> Source code in <code>src/netechos/core.py</code> <pre><code>def make_symmetric_interactions(self: Self) -&gt; Self:\n    \"\"\"Construct a random symmetric adjacency matrix.\"\"\"\n    rng = np.random.default_rng()\n    rand_mat = rng.random(size=(self.number_of_nodes, self.number_of_nodes))\n    interactions = np.where(rand_mat &lt;= self.connections, 1, 0)\n    interactions = np.maximum(interactions, interactions.transpose())\n    self.interactions = interactions\n    return self\n</code></pre>"},{"location":"api-reference/core/#src.netechos.core.NetworkModel.run_simulation","title":"<code>run_simulation(tmax)</code>","text":"<p>Simulate interaction and attitude reinforcement over time.</p> <p>Parameters:</p> Name Type Description Default <code>tmax</code> <code>int</code> <p>Number of time steps to iterate over.</p> required <p>Returns:</p> Name Type Description <code>self</code> <code>Self @ NetworkModel</code> <p>An instance of the NetworkModel object.</p> Source code in <code>src/netechos/core.py</code> <pre><code>def run_simulation(self: Self, tmax: int) -&gt; Self:\n    \"\"\"Simulate interaction and attitude reinforcement over time.\n\n    Parameters\n    ----------\n    tmax : int\n        Number of time steps to iterate over.\n\n    Returns\n    -------\n    self : Self@NetworkModel\n        An instance of the NetworkModel object.\n\n    \"\"\"\n    if tmax &lt; 1:\n        msg = \"tmax must be greater than 1\"\n        raise ValueError(msg)\n    self.initialize_summary_table()\n    self.initialize_attitude_tracker()\n    for t in tqdm(range(tmax)):\n        self.compute_attitude_difference_matrix()\n        self.make_interactions()\n        self.update_connections()\n        self.update_attitudes()\n        self.update_summary_table(time=t)\n        self.update_attitude_tracker(time=t)\n</code></pre>"},{"location":"api-reference/core/#src.netechos.core.NetworkModel.update_attitude_tracker","title":"<code>update_attitude_tracker(time)</code>","text":"<p>Construct attitude tracking table for one time.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>int</code> <p>Time index. Will be assigned to all rows of the <code>time</code> column being added to the summary table.</p> required <p>Returns:</p> Name Type Description <code>self</code> <code>Self @ NetworkModel</code> <p>An instance of the NetworkModel object.</p> Source code in <code>src/netechos/core.py</code> <pre><code>def update_attitude_tracker(self: Self, time: int) -&gt; Self:\n    \"\"\"Construct attitude tracking table for one time.\n\n    Parameters\n    ----------\n    time : int\n        Time index. Will be assigned to all rows of the `time`\n        column being added to the summary table.\n\n    Returns\n    -------\n    self : Self@NetworkModel\n        An instance of the NetworkModel object.\n\n    \"\"\"\n    attitudes_flat = self.attitudes.flatten()\n    step_attitude_tracker = pl.DataFrame(\n        {\n            \"time\": np.full(\n                shape=attitudes_flat.shape,\n                fill_value=time,\n                dtype=\"int64\",\n            ),\n            \"node\": np.arange(self.number_of_nodes, dtype=\"int64\").reshape(\n                attitudes_flat.shape,\n            ),\n            \"attitude\": attitudes_flat,\n        },\n    )\n    self.attitude_tracker = pl.concat(\n        [self.attitude_tracker, step_attitude_tracker],\n    )\n    return self\n</code></pre>"},{"location":"api-reference/core/#src.netechos.core.NetworkModel.update_attitudes","title":"<code>update_attitudes()</code>","text":"<p>Calculate change in attitude.</p> Source code in <code>src/netechos/core.py</code> <pre><code>def update_attitudes(self: Self) -&gt; Self:\n    \"\"\"Calculate change in attitude.\"\"\"\n    connections_to_power = np.where(\n        self.connections != 0,\n        np.power(self.connections, self.adjacency_exponent),\n        0,\n    )\n    d_attitudes = np.multiply(\n        np.multiply(connections_to_power, self.interactions),\n        np.sin(self.attitude_diffs),\n    ).sum(axis=0)\n    self.attitudes = self.attitudes + (self.attitude_change_speed * d_attitudes)\n    self.attitudes = np.clip(\n        self.attitudes,\n        a_min=-np.pi / 2,\n        a_max=np.pi / 2,\n    )\n    return self\n</code></pre>"},{"location":"api-reference/core/#src.netechos.core.NetworkModel.update_connections","title":"<code>update_connections()</code>","text":"<p>Calculate change in connection strength.</p> Source code in <code>src/netechos/core.py</code> <pre><code>def update_connections(self: Self) -&gt; Self:\n    \"\"\"Calculate change in connection strength.\"\"\"\n    d_connections = np.multiply(\n        self.interactions,\n        np.sin(self.attitude_diffs),\n    )\n    self.connections = self.connections + d_connections\n    self.connections = np.clip(self.connections, a_min=0, a_max=1)\n    return self\n</code></pre>"},{"location":"api-reference/core/#src.netechos.core.NetworkModel.update_summary_table","title":"<code>update_summary_table(time)</code>","text":"<p>Construct summary of the network at one time.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>int</code> <p>Time index. Will be assigned to all rows of the <code>time</code> column being added to the summary table.</p> required <p>Returns:</p> Name Type Description <code>self</code> <code>Self @ NetworkModel</code> <p>An instance of the NetworkModel object.</p> Source code in <code>src/netechos/core.py</code> <pre><code>def update_summary_table(self: Self, time: int) -&gt; Self:\n    \"\"\"Construct summary of the network at one time.\n\n    Parameters\n    ----------\n    time : int\n        Time index. Will be assigned to all rows of the `time`\n        column being added to the summary table.\n\n    Returns\n    -------\n    self : Self@NetworkModel\n        An instance of the NetworkModel object.\n\n    \"\"\"\n    step_summary_table = pl.DataFrame(\n        {\n            \"time\": time,\n            \"attitude_mean\": np.mean(np.sin(self.attitudes)),\n            \"attitude_sd\": np.std(np.sin(self.attitudes)),\n            \"connection_mean\": np.mean(self.connections),\n            \"connection_sd\": np.std(self.connections),\n        },\n    )\n    self.summary_table = pl.concat([self.summary_table, step_summary_table])\n    return self\n</code></pre>"},{"location":"api-reference/plot/","title":"netechos.plot","text":"<p>Methods for plotting network model information.</p>"},{"location":"api-reference/plot/#src.netechos.plot.NetworkPlot","title":"<code>NetworkPlot(model, theme='ticks')</code>","text":"<p>Object with basic plotting methods for model properties.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>NetworkModel</code> <p>An instance of a nim.core.NetworkModel object.</p> required <code>theme</code> <code>str {'ticks', 'whitegrid'}</code> <p>Name of a Seaborn theme style. Used to set plot styling.</p> <code>'ticks'</code> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self @ NetworkPlot</code> <p>An instance of the NetworkPlot object.</p> Source code in <code>src/netechos/plot.py</code> <pre><code>def __init__(\n    self: Self,\n    model: NetworkModel,\n    theme: Literal[\"ticks\", \"whitegrid\", \"darkgrid\"] = \"ticks\",\n) -&gt; Self:\n    \"\"\"Object to hold plots and plotting methods.\n\n    Parameters\n    ----------\n    model : NetworkModel\n        An instance of a nim.core.NetworkModel object.\n    theme : str {'ticks', 'whitegrid'}, optional, default: 'ticks'\n        Name of a Seaborn theme style. Used to set plot styling.\n\n    Returns\n    -------\n    Self : Self@NetworkPlot\n        An instance of the NetworkPlot object.\n\n    \"\"\"\n    self.summary_table = model.summary_table\n    self.attitude_tracker = model.attitude_tracker\n    sns.set_theme(context=\"notebook\", style=theme)\n</code></pre>"},{"location":"api-reference/plot/#src.netechos.plot.NetworkPlot.attitude_and_connection_means","title":"<code>attitude_and_connection_means(fig_width=7, fig_height=3)</code>","text":"<p>Plot mean attitude over time.</p> <p>Parameters:</p> Name Type Description Default <code>fig_width</code> <code>float</code> <p>Figure width, in inches.</p> <code>7</code> <code>fig_height</code> <code>float</code> <p>Figure height, in inches.</p> <code>3</code> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self @ NetworkPlot</code> <p>An instance of the NetworkPlot object.</p> Source code in <code>src/netechos/plot.py</code> <pre><code>def attitude_and_connection_means(\n    self: Self,\n    fig_width: float = 7,\n    fig_height: float = 3,\n) -&gt; Self:\n    \"\"\"Plot mean attitude over time.\n\n    Parameters\n    ----------\n    fig_width : float, optional, default: 7\n        Figure width, in inches.\n    fig_height : float, optional, default: 3\n        Figure height, in inches.\n\n    Returns\n    -------\n    Self : Self@NetworkPlot\n        An instance of the NetworkPlot object.\n\n    \"\"\"\n    tmax = self.summary_table[\"time\"].max()\n    fig, (ax0, ax1) = plt.subplots(1, 2, figsize=(fig_width, fig_height))\n    ax0.hlines(y=0, xmin=0, xmax=tmax, color=\"#444444\")\n    sns.lineplot(\n        data=self.summary_table,\n        x=\"time\",\n        y=\"attitude_mean\",\n        ax=ax0,\n    )\n    sns.lineplot(\n        data=self.summary_table,\n        x=\"time\",\n        y=\"connection_mean\",\n        ax=ax1,\n    )\n    ax0.set_xscale(\"log\")\n    ax1.set_xscale(\"log\")\n    sns.despine(ax=ax0)\n    sns.despine(ax=ax1)\n    fig.tight_layout()\n    self.means_over_time = fig\n    return self\n</code></pre>"},{"location":"api-reference/plot/#src.netechos.plot.NetworkPlot.node_attitudes_over_time","title":"<code>node_attitudes_over_time(fig_width=5, fig_height=3)</code>","text":"<p>Plot individual node attitudes over time.</p> <p>Parameters:</p> Name Type Description Default <code>fig_width</code> <code>float</code> <p>Figure width, in inches.</p> <code>7</code> <code>fig_height</code> <code>float</code> <p>Figure height, in inches.</p> <code>3</code> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self @ NetworkPlot</code> <p>An instance of the NetworkPlot object.</p> Source code in <code>src/netechos/plot.py</code> <pre><code>def node_attitudes_over_time(\n    self: Self,\n    fig_width: float = 5,\n    fig_height: float = 3,\n) -&gt; Self:\n    \"\"\"Plot individual node attitudes over time.\n\n    Parameters\n    ----------\n    fig_width : float, optional, default: 7\n        Figure width, in inches.\n    fig_height : float, optional, default: 3\n        Figure height, in inches.\n\n    Returns\n    -------\n    Self : Self@NetworkPlot\n        An instance of the NetworkPlot object.\n\n    \"\"\"\n    tmax = self.attitude_tracker[\"time\"].max()\n    self.attitude_tracker = self.attitude_tracker.with_columns(\n        attitude_sin=pl.col(\"attitude\").sin(),\n    )\n    fig, ax = plt.subplots(figsize=(fig_width, fig_height))\n    ax.hlines(y=0, xmin=0, xmax=tmax, color=\"#444444\")\n    sns.lineplot(\n        data=self.attitude_tracker,\n        x=\"time\",\n        y=\"attitude_sin\",\n        hue=\"node\",\n        ax=ax,\n    )\n    sns.despine(ax=ax)\n    sns.move_legend(ax, loc=\"upper left\", bbox_to_anchor=(1, 1))\n    fig.tight_layout()\n    self.means_over_time = fig\n    return self\n</code></pre>"},{"location":"concepts/model/","title":"Model","text":""},{"location":"concepts/model/#initial-conditions","title":"Initial conditions","text":""},{"location":"concepts/model/#network-generation","title":"Network generation","text":"<p>The initial social network, network, \\(\\mathcal{G}\\), is constructed according to standard network construction algorithms the user can select from.</p> Available network constructors <ul> <li><code>complete</code>: A graph in which every node is connected to every other node.</li> <li><code>erdos_renyi</code>: An Erd\u0151s-R\u00e9nyi random graph.</li> <li><code>watts_strogatz</code>: A Watts\u2013Strogatz small-world graph.</li> <li><code>newman_watts_strogatz</code>: A Newman\u2013Watts\u2013Strogatz small-world graph.</li> <li><code>barabasi_albert</code>: A random graph generated by Barab\u00e1si\u2013Albert preferential attachment.</li> </ul>"},{"location":"concepts/model/#attitude-specification","title":"Attitude specification","text":"<p>Each node in \\(\\mathcal{G}\\) is assigned an initial attitude, \\(\\theta_i\\), sampled from a specified distribution and are constrained to the range \\([-\\frac{\\pi}{2}, \\frac{\\pi}{2}]\\).</p> Available attitude distributions <ul> <li><code>normal</code>: A Gaussian normal distribution.</li> <li><code>uniform</code>: A uniform distribution.</li> <li><code>laplace</code>: A Laplace distribution.</li> <li><code>vonmises</code>: A von Mises distribution.</li> </ul>"},{"location":"concepts/model/#dynamics","title":"Dynamics","text":"<p>The time dynamics of the network's edges and node attitudes are governed by:</p> <pre>\\[\nA_{ij}'(t) = T_{ij}(t) \\sin(\\Theta_{ij}(t))\n\\]</pre> <pre>\\[\n\\theta_i'(t) = \\beta \\sum_j T_{ij}(t) A_{ij}^\\alpha(t) \\sin(\\Theta_{ij}(t))\n\\]</pre> <p>where \\(\\alpha\\) and \\(\\beta\\) are scaling parameters and \\(\\mathbf{T}(t)\\) is an interaction matrix constructing by generating a random matrix, \\(\\mathbf{M}(t)\\), with elements in \\([0, 1)\\) and comparing it to the network's adjacency matrix, \\(\\mathbf{A}(t)\\). Where \\(M_{ij}(t) &lt; A_{ij}(t)\\), \\(T_{ij}(t) = 1\\) and nodes \\(i\\) and \\(j\\) interact. Otherwise \\(T_{ij} = 0\\) and nodes \\(i\\) and \\(j\\) don't interact at that time. where \\(\\Theta_{ij}(t)\\) are the elements of the matrix of differences in node attitudes:</p> <pre>\\[\n\\mathbf{\\Theta}_{ij}(t) = \\mathbf{\\theta_i}(t) - \\mathbf{\\theta_j}(t)\n\\]</pre> <p>This produces an adaptive complex network where edge strengths and node attitudes are reinforced according to each other over time.</p> <p>When \\(\\mathbf{A}(t)\\) is symmetric, this is a modified Kuramoto model (Kuramoto, 1975), with the modifications:</p> <ol> <li>The mean over all phases is replaced by the simple sum.</li> <li>The coupling constant is the adjacency matrix of the network, which may be weighted.</li> <li>The coupling constant has an exponent.</li> </ol> <p>When \\(\\mathbf{A}(t)\\) isn't symmetric, this is a circle map (Arnol'd, 1961; Ott, 2002).</p>"},{"location":"concepts/notation/","title":"Notation","text":"Variable Definition \\(t\\) Time. \\(N\\) Number of nodes in the network. \\(\\mathbf{A}\\) The \\(N \\times N\\) adjacency matrix of the social network. A discrete function of time. Entries are the weights of the edges connecting the \\(i\\)-th and \\(j\\)-th nodes. \\(\\mathbf{T}\\) An \\(N \\times N\\) interaction matrix. Entries are \\(1\\) or \\(0\\) denoting whether nodes \\(i\\) and \\(j\\) interact at time \\(t\\). \\(\\mathbf{M}\\) An \\(N \\times N\\) matrix of uniform random numbers between \\(0\\) and \\(1\\). Used to determine which nodes interact at time \\(t\\). \\(\\mathbf{\\theta}\\) A length \\(N\\) column vector of node attitudes. \\(\\mathbf{\\Theta}\\) An \\(N \\times N\\) matrix of differences between attitudes \\(\\mathbf{\\theta}\\) of the nodes in the network. \\(\\mathbf{\\alpha}\\) Scaling parameter governing the dependence of attitude reinforcement on the adjacency matrix. This is a complexity parameter. \\(\\mathbf{\\beta}\\) Scaling parameter governing the rate of attitude change. Smaller values slow change."},{"location":"concepts/overview/","title":"Overview","text":"<p>Network echos treats the dynamics of a network self-organizing in response to information diffusion as the result of two network properties, connections and attitudes, which are interdependent and change over time according to a reinforecement mechanism.</p>"},{"location":"concepts/overview/#connections-and-attitudes","title":"Connections and attitudes","text":"<p>Connections are represented by the adjacency matrix of the network as weighted edges with weights constrained to the interval \\([0, 1]\\). These edge weights are used as the probability of each pair of nodes interacting over time.</p> <p>Attitudes are represented as positions on the unit semicircle from \\([-\\frac{\\pi}{2}, \\frac{\\pi}{2}\\)]. This maps the sine of each attitude to the interval \\([-1, 1]\\).</p>"},{"location":"concepts/overview/#interaction-and-adaptation","title":"Interaction and adaptation","text":"<p>Each time step, nodes interact randomly with the weights of edges in the adjacency matrix acting as interaction probabilities. When two nodes interact, each node's attitude is reinforced, positively or negatively according to whether they agree or disagree, by an amount proportional to the magnitude of attitude difference between them and their existing edge weight. Simultaneously, the weight of the edge connecting the interacting nodes is also reinforced, again positively or negatively, by an amount proportional to the magnitude of attitude difference between them.</p>"},{"location":"concepts/overview/#reinforcement-dynamics","title":"Reinforcement dynamics","text":"<p>The model uses two parameters, \\(\\alpha\\) and \\(\\beta\\), to govern the reinforcement dynamics. The \\(\\alpha\\) parameter tunes the amount by which nodes' attitudes are reinforced by acting as an exponent on the adjacency matrix. The sign of this parameter determines whether interaction with opposing attitude nodes strengthens (positive) or weakens (negative) the nodes' attitudes.</p> <p>The parameter \\(\\beta\\) governs the speed at which nodes change their attitudes. It is a constant which modulates the magnitude of attitude reinforcement. When \\(\\beta\\) is large, attitudes change rapidly, and as \\(\\beta\\) becomes smaller they change more slowly. The sign of this parameter governs whether the network tends to polarize or synchronize over time. If positive, as default, the reinforcemnt tends to polarize the network, if negative the reinforcement tends to synchronize the network.</p>"},{"location":"user-guide/getting-started/","title":"Getting started","text":"<p>This notebook is an example of how to use the network echos modeling framework.</p> <p>Start by importing the model's classes, and matplotlib for plotting support later on.</p> In\u00a0[10]: Copied! <pre>import matplotlib.pyplot as plt\n\nfrom netechos.core import NetworkModel\nfrom netechos.plot import NetworkPlot\n</pre> import matplotlib.pyplot as plt  from netechos.core import NetworkModel from netechos.plot import NetworkPlot  <p>With the modules imported, you can access all of the model's functionality. To run a model, invoke <code>NetworkModel</code> from the <code>netechos.core</code> module to create an instance of the model object. The object will store all the data and serve as the model interface.</p> In\u00a0[11]: Copied! <pre>nemodel = NetworkModel(\n    number_of_nodes=100,\n    interaction_type=\"symmetric\",\n)\n</pre> nemodel = NetworkModel(     number_of_nodes=100,     interaction_type=\"symmetric\", ) <p>With the model object instantiated as <code>nemodel</code>, you can use its attached methods to perform operations. For example, if you wanted to simulate with an Erd\u0151s-R\u00e9nyi random network as your basis, you could initialize the starting network for that like so:</p> In\u00a0[12]: Copied! <pre>nemodel.create_network(network_type=\"erdos_renyi\", p=0.3)\n</pre> nemodel.create_network(network_type=\"erdos_renyi\", p=0.3) Out[12]: <pre>&lt;netechos.core.NetworkModel at 0x1232197fef0&gt;</pre> <p>Simulations also depend on the individual attitudes of the in the basis network and the connections between them, which you can initalize like so:</p> In\u00a0[13]: Copied! <pre>nemodel.initialize_connections()\nnemodel.initialize_attitudes()\n</pre> nemodel.initialize_connections() nemodel.initialize_attitudes() Out[13]: <pre>&lt;netechos.core.NetworkModel at 0x1232197fef0&gt;</pre> <p>The <code>initialize_connections()</code> and <code>initialize_attitudes()</code> methods each include several optional arguments you can specify to customize how the initial connections and attitudes are assigned.</p> <p>With the basis network, connections, and attitudes all initialized on the model object, you can now run a simulation.</p> In\u00a0[14]: Copied! <pre>nemodel.run_simulation(tmax=1000)\n</pre> nemodel.run_simulation(tmax=1000) <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1000/1000 [00:00&lt;00:00, 1584.67it/s]\n</pre> <p>Once the simulation is complete, the model object can be passed to <code>NetworkPlot</code> from the <code>netechos.plot</code> module to see how the simulation went. This module allows quick access to simple aspects of the simulation results.</p> In\u00a0[15]: Copied! <pre>neplot = NetworkPlot(nemodel)\n</pre> neplot = NetworkPlot(nemodel) <p>You can examine how the mean node attitudes and mean connection strength evolved over time:</p> In\u00a0[16]: Copied! <pre>means_over_time = neplot.attitude_and_connection_means()\nplt.show(means_over_time)\n</pre> means_over_time = neplot.attitude_and_connection_means() plt.show(means_over_time) <p>And you can view how each individual node's attitude evolved over time:</p> In\u00a0[17]: Copied! <pre>attitudes_over_time = neplot.node_attitudes_over_time()\nplt.show(attitudes_over_time)\n</pre> attitudes_over_time = neplot.node_attitudes_over_time() plt.show(attitudes_over_time) <p>For large networks, e.g., 1000+ nodes, this individual node plot will be slow and unhelpful, but it can be used with a smaller network to give an illustrative example to pair with the plot of the means earlier.</p>"},{"location":"user-guide/getting-started/#getting-started","title":"Getting started\u00b6","text":""},{"location":"user-guide/getting-started/#initializing-a-model","title":"Initializing a model\u00b6","text":""},{"location":"user-guide/getting-started/#running-a-simulation","title":"Running a simulation\u00b6","text":""},{"location":"user-guide/getting-started/#reviewing-a-simulation","title":"Reviewing a simulation\u00b6","text":""}]}